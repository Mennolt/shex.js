'use strict'

/**
 * script to construct a Makefile based on package.json .dependencies
 */
const Fs = require('fs')
const Path = require('path')

const Out = process.stdout // could be a file stream

const ToRepoRoot = '..' // path from here to repo root
const PackagesDir = 'packages' // path from repo root to packages
const PackagesPath = Path.join(__dirname, ToRepoRoot, PackagesDir)

const pkgInfo = readPackagesAndTsConfigs()

// informative header
Out.write(`# generated by ${Path.relative(Path.join(__dirname, ToRepoRoot), __filename)} ${new Date().toISOString()}

`)

// write each rule
const allTargets = Object.keys(pkgInfo)
  .sort() // minimize diffs by keeping Makefile in consistent order
  .reduce((allTargets, pkg) => {
    const info = pkgInfo[pkg]
    if (info.tsConfig === null)
      return allTargets
    const deps = Object.keys(info.pkg.dependencies || [])
      .filter(dep => dep in pkgInfo && pkgInfo[dep].tsConfig !== null)
      .map(
        dep => getSourceOrTargetFilePaths(pkgInfo[dep], pkgInfo[dep].tsConfig.compilerOptions.outDir, '.js')
      )
    const sources = getSourceOrTargetFilePaths(info, info.tsConfig.compilerOptions.rootDir, '.ts')
    const targets = getSourceOrTargetFilePaths(info, info.tsConfig.compilerOptions.outDir, '.js')
    allTargets.push(... targets)
    const leftSide = targets.join(' ')
    const rightSide = sources
      .concat(deps)
      .concat([
        Path.join(PackagesDir, info.packageDir, 'package.json'),
        Path.join(PackagesDir, info.packageDir, 'tsconfig.json'),
      ]).join(' ')
    Out.write(`# ${pkg}
${leftSide}: ${rightSide}
\t(cd ${Path.join(PackagesDir, info.packageDir)} && tsc)

`)
    return allTargets
  }, [])

// add an ALL target
Out.write(`ALL: ${allTargets.join(' ')}

`)


/**
 * Walks subdirectories or PackagesPath to build an index of package.json and tsconfig.json files
 *
 * @returns {{packageDir, srcShortFile, pkg, tsConfig, siblings}}
 */
function readPackagesAndTsConfigs() {
  return Fs.readdirSync(PackagesPath).reduce((pkgInfo, packageDir) => {
    const packageFile = Path.join(PackagesPath, packageDir, "package.json")
    const pkg = JSON.parse(Fs.readFileSync(packageFile, "utf8"))
    const tsConfigFile = Path.join(PackagesPath, packageDir, "tsconfig.json")

    const tsConfig = Fs.existsSync(tsConfigFile)
      ? JSON.parse(Fs.readFileSync(tsConfigFile, "utf8"))
      : null

    const srcShortFile = tsConfig === null
      ? null
      : Path.join(PackagesDir, packageDir, pkg.types)

    const siblings = tsConfig === null
      ? null
      : srcSiblings(pkg, packageDir, srcShortFile)

    const name = pkg.name
    pkgInfo[name] = {packageDir, srcShortFile, pkg, tsConfig, siblings}

    return pkgInfo
  }, {})
}

/**
 * Find the source files in the same directory as srcShortFile
 * @param pkg
 * @param packageDir
 * @param srcShortFile
 * @returns {string[]} list of sibling files
 */
function srcSiblings(pkg, packageDir, srcShortFile) {
  Path.join(srcShortFile, ToRepoRoot)
  const srcAbsFile = Path.join(PackagesPath, packageDir, pkg.types)
  const srcAbsDir = Path.join(srcAbsFile, ToRepoRoot)
  return Fs.readdirSync(srcAbsDir)
    .filter(f => srcAbsFile !== Path.join(srcAbsDir, f))
    .map(f => f.replace(/\.ts$/, ''))
}

/**
 *
 * @param info
 * @param relDir
 * @param ext
 * @returns {unknown[]}
 */
function getSourceOrTargetFilePaths(info, relDir, ext) {
  const sourceFileName = Path.relative(info.tsConfig.compilerOptions.rootDir, info.pkg.types)
  return [sourceFileName.replace(/\.ts$/, "")].concat(info.siblings).map(
    fn => Path.join(PackagesDir, info.packageDir, relDir, fn) + ext
  )
}

