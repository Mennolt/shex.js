#!/usr/bin/env node

/*
validate -n <node> -d <data> -s <shape> -x <schema>
Validate node in data as shape in schema.

example invocations:
 from teh interwebs:
  validate -n http://a.example/Issue1 -d issues.ttl -s http://b.example/IssueShape -x http://tracker.example/schemas/Issue.shex

 from shex.js co with neighboring shexTest:
  ./bin/validate -x ../shexTest/schemas/1dotCode3.shex -s http://a.example/S1 -d ../shexTest/validation/IIssue1_Ip1_Io1.ttl -n http://a.example/Issue1


Extensions are loaded from ../extensions/*.js .
Running the test extension <http://shex.io/extensions/Test/> adorns the results with:
  "semActResults": {
    "extension": "http://shex.io/extensions/Test/",
    "effects": [
      "http://a.example/Issue1",
      "http://a.example/p1",
      "http://a.example/o1"
    ]
  }

The regular expression engine is loaded from either:
  absolute path, e.g. if you git cloned shex.js into /tmp:
    --regex-module /tmp/shex.js/packages/eval-simple-1err/eval-simple-1err
    --regex-module /tmp/shex.js/packages/eval-threaded-nerr/eval-threaded-nerr
  or relative path to bin/validate directory:
    --regex-module ../packages/eval-simple-1err/eval-simple-1err
    --regex-module ../packages/eval-threaded-nerr/eval-threaded-nerr
  or a module name in lib/regex:
    --regex-module eval-simple-1err
    --regex-module eval-threaded-nerr

*/

const Fs = require("fs");
const Path = require("path");
const Util = require("util");
const JsYaml = require('js-yaml');
const ShExUtil = require("@shexjs/util");
const {ShExIndexVisitor} = require("@shexjs/visitor");
const {StoreDuplicates, yyllocToString, Merger: ShExMerger} = require("@shexjs/util/lib/Merger");
const { ctor: RdfJsDb } = require('@shexjs/neighborhood-rdfjs');
const { ctor: SparqlDb } = require('@shexjs/neighborhood-sparql');
const ShExTerm = require("@shexjs/term");
const ShExParser = require("@shexjs/parser");
const ShExWriter = require("@shexjs/writer"); // for verbose output
const {ShExValidator, resultMapToShapeExprTest} = require("@shexjs/validator");
const ShapeMap = require("shape-map");
const N3 = require("n3");
const ShExNode = require("@shexjs/node")({
  rdfjs: N3,
  fetch: require('node-fetch'),
  jsonld: require('jsonld'),
});
const ExitCode = require('../lib/ExitCode')

ShapeMap.Start = ShExValidator.Start; // Tell the ShapeMap parser to use ShExValidator's start symbol. @@ should be a function

const ValidatorOptions = { diagnose: true };
const SchemaOptions = {
  duplicateShape: "abort",
  index: true,
  collisionPolicy: ShExUtil.warnDuplicates,
};

// const RunMode = { NORMAL: 0, ERROR: 1, DRYRUN: 2, USAGE: 4, HELP: 6 };
const REGEX_MODULES = "../lib/regex/";
const MISC_NODES = true; // validate nodes not found in data.
const START_SHAPE_LABEL = "START";
const RDF_TYPE= "http://www.w3.org/1999/02/22-rdf-syntax-ns#type";
const covgChoices = Object.keys(ShExValidator.InterfaceOptions.coverage).join("|");
const dupChoices =  ["abort", "replace", "ignore"].join("|"); // lib/ShExJison.jison::addShape(label, shape)
const TraitToOption = { eachOf: "or", oneOf: "or", someOf: "or", exhaustive: "coverage", firstError: "coverage" };

const CommandLineOptions = [
  { name: "verbose",   alias: "v", type: Boolean , description: "print extra information" },           //
  { name: "quiet",     alias: "q", type: Boolean , description: "don't print anything" },              // switch to logger
  { name: "terse",     alias: "Q", type: Boolean , description: "don't print diagnistics or advice" }, //
  { name: "human",                 type: Boolean , description: "print human-readable results" }, //
  { name: "query",                 type: Boolean , description: "show matching RDF graph" },
  { name: "remainder",             type: Boolean , description: "show triples not touched by validation" },
  { name: "grep",                  type: Boolean },
  { name: "list",                  type: Boolean },
  { name: "track",                 type: Boolean , description: "display graph nodes touched by validation" },
  { name: "slurp",                 type: Boolean , description: "record minimal neighborhoods needed by validation" },
  { name: "slurp-all",             type: Boolean , description: "record complete neighborhoods visited by validation. implies --slurp; may be the same as --slurp, depending on the databse" },
  { name: "help",      alias: "h", type: Boolean , description: "print usage information and quit" },
  { name: "node",      alias: "n", type: String, typeLabel: "RDFTerm",   multiple: false, defaultValue: undefined, description: "node to validate" },
  { name: "node-type", alias: "t", type: String, typeLabel: "IRI",       multiple: false, defaultValue: undefined, description: "validate nodes of this type" },
  { name: "queryMap",  alias: "m", type: String, typeLabel: "string",    multiple: false, defaultValue: undefined, description: "QueryMap" },
  { name: "mapURL",    alias: "M", type: String, typeLabel: "file|URL",  multiple: false, defaultValue: undefined, description: "QueryMap" },
  { name: "shape",     alias: "s", type: String, typeLabel: "IRI|Bnode", multiple: false, defaultValue: undefined, description: "shape to validate" },
  { name: "schemaURL", alias: "x", type: String, typeLabel: "file|URL",  multiple:  true, defaultValue:        [], description: "ShExC schema" },
  { name: "json",      alias: "j", type: String, typeLabel: "file|URL",  multiple:  true, defaultValue:        [], description: "ShExJ schema" },
  { name: "dataURL",   alias: "d", type: String, typeLabel: "file|URL",  multiple:  true, defaultValue:        [], description: "Turtle data", defaultOption: true },
  { name: "jsonld",    alias: "l", type: String, typeLabel: "file|URL",  multiple:  true, defaultValue:        [], description: "JSON-LD data" },
  { name: "endpoint",              type: String, typeLabel: "IRI",       multiple: false, defaultValue: undefined, description: "data query endpoint" },
  { name: "extension",             type: String, typeLabel: "file glob", multiple:  true, defaultValue:        [], description: "ShExC schema" },
  { name: "result",                type: String, typeLabel: "file|URL",  multiple: false, defaultValue: undefined, description: "expected JSON results" },
  { name: "serve",     alias: "S", type: String, typeLabel: "URL",       multiple: false, defaultValue: undefined, description: "server" },
  { name: "serve-n",               type: Number, typeLabel: "integer",   multiple: false, defaultValue:        -1, description: "serve N times and exit" },
  { name: "exec",                  type: String, typeLabel: "javascript code",            defaultValue: undefined, description: "run some js code with results" },
  { name: "duplicate-shape",       type: String, typeLabel: dupChoices,  multiple: false, defaultValue: undefined, description: "what to do with duplicate shapes" },
  { name: "diagnose",              type: Boolean, description: "parse and diagnose schema, the exit" },
  { name: "skipCycleCheck",        type: Boolean, description: "don't look for cycles in schema" },
  { name: "coverage",              type: String, typeLabel: covgChoices, multiple: false, defaultValue: undefined, description: "whether to collect all errors or stop on the first one" },
  { name: "yaml-manifest",         type: String, typeLabel: "file|URL",  multiple:  true, defaultValue:        [], description: "JSON manifest" },
  { name: "json-manifest",         type: String, typeLabel: "file|URL",  multiple:  true, defaultValue:        [], description: "JSON manifest" },
  { name: "turtle-manifest",       type: String, typeLabel: "file|URL",  multiple:  true, defaultValue:        [], description: "Turtle manifest" },
  { name: "jsonld-manifest",       type: String, typeLabel: "file|URL",  multiple:  true, defaultValue:        [], description: "JSON-LD manifest" },
  { name: "test-name",             type: String, typeLabel: "IRI",       multiple:  true, defaultValue:        [], description: "what tests to run in the manifest (.name OR .schemaLabel/.dataLabel)" },
  { name: "invocation",alias: "i", type: Boolean, desc: "show invocation" },
  { name: "dry-run",   alias: "N", type: Boolean, desc: "prepare validation but don't execute" },
  { name: "regex-module",          type: String, typeLabel: "js module", multiple: false, defaultValue: undefined, description: "what regular expression module to use" },
];

// Generate command line interface
const Argv1 = Path.relative("", process.argv[1]);
const CliDir = Path.relative("", Path.resolve(__dirname, "../test/cli")) + Path.sep;
// Extract user commands
main();

async function main () {

  let cmds;
  try {
    cmds = require("command-line-args")(CommandLineOptions);
  } catch (e) {
    abort(e.message, ExitCode.bad_argument);
  }

  if (cmds.help)
    abort("", ExitCode.help);

  if ("duplicate-shape" in cmds)
    SchemaOptions.duplicateShape = cmds["duplicate-shape"];

  if (cmds.coverage) {
    if (!(cmds.coverage in ShExValidator.InterfaceOptions.coverage))
      throw Error("unknown coverage option \"" + cmds.coverage + "\" - expected one of " + Object.keys(ShExValidator.InterfaceOptions.coverage).join(", ") + "\".");
    ValidatorOptions.coverage = cmds.coverage;
  }

  if (cmds["turtle-manifest"].length || cmds["jsonld-manifest"].length) {
    const exitCode = await loadRDFmanifest(cmds);
    process.on('exit', function() { process.exit(exitCode); });
  } else if (cmds["yaml-manifest"].length) {
    const results = await Promise.all(loadJSONmanifest(cmds["yaml-manifest"], JsYaml.load, cmds));
    // exit with a 0 if all returned 0, else a failure code.
    process.on('exit', function() { process.exit(results.reduce(function (soFar, result) {
      return soFar ? soFar : result;
    }, 0)); });
  } else if (cmds["json-manifest"].length) {
    const results = await Promise.all(loadJSONmanifest(cmds["json-manifest"], JSON.parse, cmds));
    // exit with a 0 if all returned 0, else a failure code.
    process.on('exit', function() { process.exit(results.reduce(function (soFar, result) {
      return soFar ? soFar : result;
    }, 0)); });
  } else {
    const ret = await loadCommandLine(cmds);
    process.on('exit', function() { process.exit(ret); });
  }
}

function abort (msg, exitCode) {
  const output = exitCode === ExitCode.help ? console.log : console.error;
  output(msg);
  output(require('command-line-usage')([
    {
      header: 'validate',
      content: 'validate nodes in RDF graphs with respect to ShEx schemas.'
    },
    {
      header: 'Synopsis',
      content: [
        "validate (-x <ShExC> | -j <ShExJ>) -s <start shape> (-d <Turtle> | -l <JSON-LD>) -n <start node>",
        "validate (-x |-j)? (-s)? (-d|-l)? (-n)? -S http://localhost:8088/validate"
      ]
    },
    {
      header: 'Options',
      optionList: CommandLineOptions
    },
    {
      header: 'Examples',
      content: [
        { l: "validate local files by node and shape:",
          r: Util.format('  validate -x %s1dotOr2dot.shex -d %sp2p3.ttl -n x -s http://a.example/S1', CliDir, CliDir) },
        { l: "validate local files with a ShapeMap:",
          r: Util.format('  validate -x %s1dotOr2dot.shex -d %sp2p3.ttl -m \'<x>@<http://a.example/S1>\'', CliDir, CliDir) },
        { l: "validate local files with a QueryMap:",
          r: Util.format('  validate -x %s1dotOr2dot.shex -d %sp2p3.ttl -m \'\\{FOCUS :p2 _\\}@<http://a.example/S1>\'', CliDir, CliDir) },
        { l: "validate web resources:",
          r: "  validate -x http://shex.io/examples/IssueSchema.shex -d http://shex.io/examples/Issue1.ttl -m '<#Issue1>@<#IssueShape>'" },
        { l: "validate schema:",
          r: "  validate -x http://shex.io/examples/IssueSchema.shex --diagnose" },
        { l: "run as a server:",
          r: Util.format('  validate -S http://localhost:8088/validate') },
        { l: "",
          r: Util.format('  curl -i http://localhost:8088/validate -F "schema=@%s1dotOr2dot.shex" -F "shape=http://a.example/S1" -F "data=@%sp2p3.ttl" -F "node=x"', CliDir, CliDir) },
        { l: "run as a preloaded server:",
          r: Util.format('  validate -x %s1dotOr2dot.shex -s http://a.example/S1 -S http://localhost:8088/validate', CliDir) },
        { l: "",
          r: Util.format('  curl -i http://localhost:8088/validate -F "data=@%sp2p3.ttl" -F "node=x"', CliDir) }
      ]
    },
    {
      content: "Project home: " + require('chalk').underline("https://github.com/shexSpec/shex.js")
    }
  ]));
  process.exit(exitCode);
}

class TermError extends Error {  }

/* Leverage N3.js's relative IRI parsing.
 * !! requires intimate (so intimate it makes me blush) knowledge of N3.js.
 */
async function findNodesAndValidate (loaded, parms, options, schemaStart, cmds) {
  let shapeIndex = loaded.schema._shapes || ShExIndexVisitor.index(loaded.schema)
  function knownShape (label) {
    return label in shapeIndex.shapeExprs;
  }
  function unknownShape (label) {
    throw new TermError(label + " not found in\n" + Object.keys(shapeIndex.shapeExprs).map(n => "  " + n + "\n").join(''));
  }
  function someShape () {
    return Object.keys(shapeIndex.shapeExprs)[0];
  }
  function knownNode (label) {
    return (loaded.data.getQuads(label, null, null).length > 0 ||
            loaded.data.getQuads(null, null, label).length > 0);
  }
  function knownType (label) {
    return (loaded.data.getQuads(null, RDF_TYPE, label).length > 0);
  }
  function someIRInode () {
    const triples = loaded.data.getQuads(null, null, null);
    for (let i = 0; i < triples.length; ++i)
      if (triples[i].subject.termType === "NamedNode")
        return triples[i].subject;
    return triples.length > 0 ? triples[0].subject : ShExUtil.NotSupplied;
  };
  function allNodesWithType (type) {
    const triples = loaded.data.getQuads(null, RDF_TYPE, type);
    return triples.length > 0 ? triples.map(t => t.subject) : [ShExUtil.NotSupplied];
  };
  function getQuads (s, p, o) {
    const get = s === ShapeMap.Focus ? "subject" : "object";
    return loaded.data.getQuads(mine(s), mine(p), mine(o)).map(
      t => t[get]
    );
    function mine (term) {
      return term === ShapeMap.Focus || term === ShapeMap.Wildcard
        ? null
        : term;
    }
  }
  const shapeMapExtensions = {
    "http://www.w3.org/ns/shex#Extensions-sparql": function (query) {
      const prefixesStr = loaded.dataMeta.length > 0
            ? Object.keys(loaded.dataMeta[0].prefixes).map(
              k => `PREFIX ${k}: <${loaded.dataMeta[0].prefixes[k]}>\n`
            ).join("")
            : "";
      return ShExUtil.executeQuery(prefixesStr + query, parms.endpoint, N3.DataFactory).map(row => row[0]);
    }
  }

  function _makeShapeMap (nodeP, shapeP, nodeTypeP, schemaStart) {
    // resolve relative shape and focus node names against the first schema and data source respectively.
    let nodes = nodeTypeP
        ? allNodesWithType(ShExUtil.parsePassedNode(nodeTypeP, loaded.dataMeta[0],
						    null, knownType, x =>  x))
        : typeof nodeP === "object" && nodeP.type === "TriplePattern"
        ? getQuads(nodeP.subject, nodeP.predicate, nodeP.object).map(ShExTerm.rdfJsTerm2Ld)
        : typeof nodeP === "object" && nodeP.type === "Extension"
          ? shapeMapExtensions[nodeP.language](nodeP.lexical)
        : [ShExUtil.parsePassedNode(nodeP, loaded.dataMeta[0], someIRInode,
                                 MISC_NODES ? () => true : knownNode, x => x)]; // accept unknown nodes
    let shape, shapeLabel;

    if (!shapeP && loaded.schema.start) {
      shape = loaded.schema.start;
      shapeLabel = ShExValidator.Start;
      ret.shape = shapeLabel;
    } else {
      const found = typeof shapeP === "string"
            ? ShExUtil.parsePassedNode(shapeP, loaded.schemaMeta[0],
				       someShape, knownShape, unknownShape)
            : shapeP; // already a token like .start
      if (found === ShExUtil.NotSupplied || found === ShExUtil.UnknownIRI)
        throw Error("shape " + shapeP + " not defined" + optsStr(shapeP, loaded.schema.shapes));
      // shape = { type: "ShapeRef", reference: found };

      shape = found;
      shapeLabel = shapeP;
      if (shapeP === undefined)
        console.log("Guessing shape " + found);
    }

    if (nodes[0] === ShExUtil.NotSupplied)
      throw Error("node not defined and no default found" +
                  ("node-type" in parms ?
                   " looking for type " + nodeTypeP :
                   ""));
    if (!MISC_NODES && nodes[0] === ShExUtil.UnknownIRI) {
      console.warn("node " + nodeP + " not found in data" +
                   optsStr("node" in parms ? nodeP : nodes[0], loaded.data._entities));
      nodes = [nodeP];
    }

    // console.log("runValidator ("+graph+", "+node+", "+schema+", "+shape+")");
    if (nodes[0] === undefined || (shape === undefined && schemaStart === undefined)) {
      const msgs = [];
      if (nodes[0] === undefined) {
        const subjectNodes = loaded.data.size < 50 ? Object.keys(loaded.data.getQuads(null, null, null).reduce(function (r, t) { r[t.subject] = t.subject; return r; }, {})) : 0;
        msgs.push("No starting node specified" +
                  (subjectNodes.length ?
                   "; try -n with one of:\n" + subjectNodes.map(n => "  " + n + "\n").join("") :
                   "")
                 );
      }
      // Make sure we have a start node.
      if (shape === undefined && !("start" in schema)) {
        const schemaKeys = Object.keys(schema.shapes);
        schemaKeys.join(", ");
        msgs.push("No shape specified on command line or in ShEx schema" +
                  (schemaKeys.length < 50 ?
                   "; try -n with one of: " + schemaKeys.join(", ") :
                   "")
                 );
      }
      abort(msgs.join("\n"), ExitCode.bad_argument);
    }
    return nodes.map(node => ({ node: node, shape: shape }));
  }

  const ret = {};

  const shapeMap = "queryMap" in parms
      ? parms.queryMap.reduce(
        (acc, pair) => acc.concat(_makeShapeMap(pair.node, pair.shape, null, schemaStart)), []
      ).reduce(
        (acc, pair) => acc.seen.indexOf(pair.node) === -1
          ? {ret: acc.ret.concat(pair), seen: acc.seen.concat(pair.node)}
        : acc,
        {ret: [], seen: []}
      ).ret
      : _makeShapeMap(parms.node, parms.shape, parms["node-type"], schemaStart);
  if (cmds.verbose) {
    let tz = shapeMap.map(p => { return p.node + " AS " + p.shape; });
    tz = tz.length > 1 ? JSON.stringify(tz) : tz[0];
    let w;
    new ShExWriter({simplifyParentheses: false }).
      writeSchema(loaded.schema, function (error, text, prefixes) {
        if (error) throw error;
        else w = text;
      });
    const shapeIn = shapeMap ? shapeMap + " in" : "";
    console.log("validating " + tz + " over " + loaded.data.size + " triples against " + w);
  }

  ret.results = await runValidator(loaded.data, shapeMap, loaded.schema, options, cmds);
  if (typeof ret.results === 'object' && !("errors" in ret.results)) {
    if (cmds.query || cmds.remainder) {
      ret.results.graph = new N3.Store();

      // Test for .solution because `<S> .` or `<S> {}` will pass with no sollutions.
      // This is analogous to testing for `("referenced" in s)` in a TestedTriple.
      if ("solution" in ret.results)
        ShExUtil.getProofGraph(ret.results.solution, ret.results.graph, N3.DataFactory);
    }
    if (cmds.remainder) {
      const remainder = new N3.Store();
      remainder.addQuads(loaded.data.getQuads());
      ret.results.graph.getQuads().forEach(q => remainder.removeQuad(q));
      ret.results.graph = remainder;
    }
  }
  return ret;

  function optsStr (key, dict) {
    const r = RegExp(key.substr(key.lastIndexOf("/")).toLowerCase(), "i");
    const opts = Object.keys(dict).reduce(function (ret, k) {
      if (k.match(r))
        ret.push(k);
      return ret;
    }, []);
    return opts.length === 0 ? "" :
      opts.length === 1 ? ": try " + opts[0] :
      ": try one of " + opts.join(" , ");
  }
}

class ProgressLoadControler extends ShExNode.ResourceLoadControler {
  add (promise) {
    const index = this.toLoad.length;
    super.add(promise.then(ret => {
      process.stdout.clearLine();
      process.stdout.cursorTo(0);
      process.stdout.write(`Loaded ${index} of ${this.schemasSeen.length} imports: ${ret.url}`);
      return ret;
    }));
  }
  allLoaded () {
    return super.allLoaded().then(x => {
      process.stdout.clearLine();
      process.stdout.cursorTo(0);
      process.stdout.write(`Loaded ${this.toLoad.length} imports.\n`);
      return x;
    });
  }
}

async function loadSchemaAndData (valParms, validatorOptions, schemaOptions, cmds) {
  if (valParms.schemaURL.length > 1 && valParms.dataURL.length === 0) {
    valParms.dataURL = valParms.schemaURL.splice(1); // push all but first into data
  }
  if (valParms.json.length > 1 && valParms.dataURL.length === 0) {
    valParms.dataURL = valParms.json.splice(1); // push all but first into data
  }
  if (!valParms.serve && !valParms["dry-run"]) {
    if (valParms.schemaURL.length === 0 && valParms.json.length === 0) abort("No schemaURL specified", ExitCode.bad_argument);
    if (!valParms.diagnose) {
      if (valParms.dataURL.length === 0 && valParms.jsonld.length === 0) abort("No dataURL specified", ExitCode.bad_argument);
    }
  }

  const errors = [];
  const storeDuplicatesInstance = valParms.diagnose ? new StoreDuplicates() : null;
  const loadOptions = Object.assign(
    {},
    schemaOptions,
    valParms.diagnose
    ? {
      index: true,
      collisionPolicy: storeDuplicatesInstance,
      loadController: new ProgressLoadControler(valParms.schemaURL.concat(valParms.json)),
      missingReferent: (error, yylloc) => { errors.push({error, yylloc}); },
      skipCycleCheck: true,
    }
    : {  }
  );

  // Loaded schema and data.
  const schemaAndDataP = ShExNode.load(
    {shexc: valParms.schemaURL, json: valParms.json},
    {turtle: valParms.dataURL, jsonld: valParms.jsonld},
    loadOptions, undefined
  );

  // Expected results, if provided.
  const expectedResultsP = !("result" in valParms)
        ? Promise.resolve(undefined)
        : typeof valParms.result === "boolean"
        ? Promise.resolve(valParms.result)
        : ShExNode.GET(valParms.result).then(function (body) {
          return ShExUtil.absolutizeResults(JSON.parse(body.text), body.url);
        })

  // ShapeMap, if provided.
  const shapeMapP = "mapURL" in valParms
        ? ShExNode.GET(valParms.mapURL).then(function (body) {
          return { shapeMapBody: body.text, shapeMapBase: valParms.mapURL };
        })
        : Promise.resolve("queryMap" in valParms
                          ? { shapeMapBody: valParms.queryMap,
                              shapeMapBase: "file://" + Path.resolve(process.cwd()) }
                          : undefined)

  try {
    const [schemaAndData, expectedResults, shapeMap] = await Promise.all([schemaAndDataP, expectedResultsP, shapeMapP])
    /* loadedAndResults is something like: [
         { data: N3Store {…},
           dataMeta: [{
             base: "http://instance.example/",
             mediaType: "text/turtle",
             prefixes: {xsd: "http://www.w3.org/2001/XMLSchema#", …},
             url: "file:///…/shex.js/examples/ClinObs-with-birthdate.ttl"
           }],
           schema: {type: "Schema", …},
           schemaMeta: [{
             base: "http://schema.example/",
             mediaType: "text/shex",
             prefixes: {xsd: "http://www.w3.org/2001/XMLSchema#", …},
             url: "file:///…/shex.js/examples/ClinObs.shex"
           }]
         },
         { type: "ShapeTest", … },
         { shapeMapBody: '{node:"a", shape:"b"}' || "<a>@<b>"
           shapeMapBase: "http://shapeMap.example/"
         }
       ] */

    const queryTracker = valParms.track || valParms.slurp
          ? makeQueryTracker(
            metaToResolver(schemaAndData.schemaMeta[0]),
            metaToResolver(schemaAndData.dataMeta[0]))
          : null;
    schemaAndData.data = valParms.endpoint
      ? SparqlDb(valParms.endpoint, queryTracker, {allOutgoing: valParms["slurp-all"]})
      : RdfJsDb(schemaAndData.data, queryTracker);

    if (valParms.diagnose) {
      const redefined = Object.keys(storeDuplicatesInstance.duplicates);
      process.stdout.write(`, found ${Object.keys(redefined).length} redefinitions, ${errors.length} errors.\n`);
      if (redefined.length > 0) {
        console.log(`${redefined.length} Redefinitions:`);
        redefined.forEach(id => {
          const llocs = storeDuplicatesInstance.duplicates[id];
          console.log('  %s: %d defintions:%s', ShExTerm.shExJsTerm2Turtle(id), llocs.length, llocs.map(yylloc => "\n    " + yyllocToString(yylloc)).join(""));
        });
      }
      console.log(`${errors.length} Errors:\n%s`, errors.map(({error, yylloc}) => `  ${yylloc ? yyllocToString(yylloc) : ""}\n    ${error}`).join("\n"));
      if (valParms["dry-run"]) {
        return redefined.length === 0 && errors.length === 0
          ? ExitCode.dry_run
          : ExitCode.shape_test_fail;
      }
    }

    if (valParms.serve) {
      if (valParms.shape) {
        const index = ShExIndexVisitor.index(schemaAndData.schema);
        function knownShape (label) {
          return label in index.shapeExprs;
        }
        const found = ShExUtil.parsePassedNode(valParms.shape, schemaAndData.schemaMeta[0],
                                               null, knownShape, schemaAndData.schema.prefixes);
        if (found === ShExUtil.UnknownIRI)
          console.warn("Warning: could not resolve "+valParms.shape+" with loaded schema");
      }
      runServer(schemaAndData, valParms, validatorOptions, schemaOptions, cmds);
    } else {
      if (shapeMap) { // if we loaded a queryMap
        try {
          valParms.queryMap = ShExUtil.absolutizeShapeMap(JSON.parse(shapeMap.shapeMapBody),
                                                     schemaAndData.dataMeta[0].base); // @@ relative to data[0]'s base instead of shapeMap.shapeMapBase -- is that good?
        } catch (e) {
          valParms.queryMap = ShapeMap.Parser.construct(shapeMap.shapeMapBase,
                                                   schemaAndData.schemaMeta[0],
                                                   schemaAndData.dataMeta[0] || {})
            .parse(shapeMap.shapeMapBody);
        }
      }

      const valOpts2 = valParms.slurp
            ? Object.assign({}, {noResults: true}, validatorOptions)
            : validatorOptions;
      const res = (await findNodesAndValidate(schemaAndData, valParms, valOpts2, schemaAndData.schema.start, cmds)).results;

      if (cmds["dry-run"])
        return res || ExitCode.dry_run;

      const passed = !("errors" in res);
      // display results and return error codes
      if (expectedResults !== undefined) {
        const match =
              typeof expectedResults === "boolean" && expectedResults !== !passed ||
              JSON.stringify(expectedResults) == JSON.stringify(res);
        if (!valParms.quiet)
          console.log(match);
        return match ? ExitCode.val_match_pass : ExitCode.val_match_fail;
      } else {
        if (res.graph) {
          const wr = new N3.Writer({ prefixes: schemaAndData.dataMeta[0].prefixes || {} });
          wr.addQuads(res.graph.getQuads());
          let text = null;
          wr.end((error, results) => {
            if (error)
              throw error;
            text = ""
              + (res.solutions || [res]).map(
                r2 =>
                  "# <" + r2.node + ">@<" + r2.shape + ">\n").join('')
              + results.trim();
          });
          delete res.graph;
          if (text)
            console.log(text);
          else
            console.log(JSON.stringify(res, null, "  "));
          return passed ? ExitCode.graph_match_pass : ExitCode.graph_match_fail;
        } else if (!valParms.quiet && !valParms.slurp) {
          console.log(
            cmds["human"]
              ? passed
              ? `${res.node}@${res.shape}`
              : ShExUtil.errsToSimple(res)
              : JSON.stringify(res, null, "  ")
          );
          return passed ? ExitCode.shape_test_pass : ExitCode.shape_test_fail;
        }
      }
    }
  } catch (e) {
    let exitCode;
    if (e instanceof TermError) {
      exitCode = ExitCode.term_not_found;
      console.error("Term argument error:", e.message);
    } else if (e instanceof ShExNode.WebError) {
      exitCode = ExitCode.resource_not_found;
      console.error("Resource error:", e.message);
    } else if (e instanceof Error) {
      if (e.origError) {
        e = e.origError;
      }
      exitCode = e.code === "ENOENT"
        ? ExitCode.file_not_found
        : ExitCode.unspecified_error;
      console.error(e.stack);
    } else {
      exitCode = ExitCode.unspecified_error;
      console.error("Aborting:", e);
      e = Error(e);
    }
    return exitCode;
  };

  function makeQueryTracker (schemaMeta, dataMeta) {
    if (valParms.slurp) {
      console.log(Object.keys(dataMeta.meta.prefixes).map(
        prefix => `PREFIX ${prefix}: <${dataMeta.meta.prefixes[prefix]}>\n`
      ).join(""));
    }
    return {
      start: function (isOut, term, shapeLabel) {
        if (valParms.track) {
          var node = rdflib_termToLex(term, dataMeta);
          var shape = rdflib_termToLex(shapeLabel, schemaMeta);
          var slurpStatus = (isOut ? "←" : "→") + " " + node + "@" + shape;
          process.stdout.write("# " + slurpStatus);
        }
      },
      end: function (triples, time) {
        if (valParms.track)
          process.stdout.write(" " + triples.length + " triples (" + time + " μs)\n");
        if (valParms.slurp) {
          const wr = new N3.Writer({ prefixes: dataMeta.meta.prefixes || {} });
          wr.addQuads(triples);
          wr.end((error, results) => {
            if (error)
              console.warn(error.replace(/^/mg, "# "));
            else
              console.log(results.replace(/^(@prefix [^:]*: *<[^>]*> *.\n)*\n*/g, ''));
          });
        }
      }
    }
  }

  function metaToResolver (meta) {
    return meta
      ? { _base: meta.url, _basePath: meta.url, meta: {prefixes: meta.prefixes} }
      : {url: "foo:bar", prefixes: {}} ;
  }
}

function rdflib_termToLex (node, resolver) {
  if (typeof node === "object") {
    let ret = node.value
        .replace(/"/g, "\\\"")
        .replace(/\r/g, "\\r")
        .replace(/\n/g, "\\n")
        .replace(/\t/g, "\\t");
    ret = "\"" + ret + "\"";
    if ("language" in node)
      ret = ret + "@" + node.language;
    if ("datatype" in node)
      ret = ret + "^^" + rdflib_termToLex(node.datatype, resolver);
    return ret;
  }
  if (node.startsWith("_:"))
    return node;
  if (node === "http://www.w3.org/1999/02/22-rdf-syntax-ns#type")
    return "a";
  if (node === ShExValidator.Start)
    return START_SHAPE_LABEL;
  if (node === resolver._base)
    return "<>";
  if (node.indexOf(resolver._base) === 0/* &&
                                           ['#', '?'].indexOf(node.substr(resolver._base.length)) !== -1 */)
    return "<" + node.substr(resolver._base.length) + ">";
  if (node.indexOf(resolver._basePath) === 0 &&
      ['#', '?', '/', '\\'].indexOf(node.substr(resolver._basePath.length)) === -1)
    return "<" + node.substr(resolver._basePath.length) + ">";
  return new N3.Writer({ prefixes:resolver.meta.prefixes || {} })._encodeObject(N3.DataFactory.namedNode(node));
}

function getInvocation (parms) {
  function shortenFile (u) {
    const m = u.match(/file:\/\/(\/.*)$/);
    if (m)
      u = Path.relative(process.cwd(), m[1]);
    return "'"+u+"'";
  }
  function shexFileArg (u) { return u ? "-x "+shortenFile(u) : ''; }
  function jsonFileArg (u) { return u ? "-j "+shortenFile(u) : ''; }
  function dataFileArg (u) { return u ? "-d "+shortenFile(u) : ''; }
  function jsonldFileArg (u) { return u ? "-l "+shortenFile(u) : ''; }
  const res = [Path.relative(process.cwd(), Argv1),
             parms.schemaURL.map(shexFileArg).join(' '),
             parms.json.map(jsonFileArg).join(' '),
             parms.dataURL.map(dataFileArg).join(' '),
             parms.jsonld.map(jsonldFileArg).join(' '),
             parms.shape ? "-s " + parms.shape : '',
             parms.node ? "-n " + parms.node : '',
             parms.mapURL ? "-M " + parms.mapURL : '',
             parms.queryMap ? "-m " + parms.queryMap : ''
            ];
  if ("options" in parms)
    Object.keys(parms.options).forEach(k => { // e.g. --regex-module eval-simple-1err
      res.push("--" + k.replace(/([A-Z])/g, function (c) {
        return "-" + c.toLowerCase();
      }) + " " + parms.options[k]);
    });
  if ("result" in parms)
    res.push("--result " + // results are booleans or filenames
             (typeof parms.result === "string" ?
              shortenFile(parms.result) :
              parms.result));
  return res.join(' ');
}

/* queueTests - take a structure like
[ { json: [],
    validatorOptions: {},
    schemaURL: [ 'file:///tmp/t/t.shex' ],
    shape: 'http://www.w3.org/fhir-rdf-shapes/MedicationOrder',
    dataURL: [ 'file:///tmp/t/t.ttl' ],
    node: 'file:///tmp/t/MedicationOrder/12345-67' } ]
and some constructor args like {or: "someOf", coverage: "exhaustive"}
*/
async function queueTests (tests, cmds) {
  const results = await Promise.all(tests.map(function (test) {
    // run each test and return the result (0 or 2, so far)
    if (cmds.invocation) {
      console.log(getInvocation(test));
    }
    if ("regexModule" in test.validatorOptions)
      test.validatorOptions.regexModule = getRegexModule(cmds["regexModule"]);
    const schemaOptions = Object.assign({}, SchemaOptions, test.schemaOptions || {});
    return loadSchemaAndData(test, test.validatorOptions, schemaOptions, cmds);
  }))
  // exit with a 0 if all returned 0, else hightest (worst) ExitCode.x code.
  return results.reduce(function (worst, result) {
    return worst < result ? result : worst;
  }, 0);
}

async function runValidator (db, shapeMap, schema, options, cmds) {
  // prepare validator
  const validator = new ShExValidator(schema, db, options);
  const extensions = ShExNode.loadExtensions(cmds.extension);
  Object.keys(extensions).forEach(function (ext) {
    extensions[ext].register(validator);
  });

  if (cmds["dry-run"])
    return 0;

  // run validator
  const res = cmds.grep
      ? await grep(shapeMap)
      : resultMapToShapeExprTest(await validator.validateShapeMap(shapeMap));

  Object.keys(extensions).forEach(function (ext) {
    extensions[ext].done(validator);
  });

  // display results
  if (cmds.exec) {
    /* example usage:
       ./bin/validate -x test/Map/BPFHIR.shex -d test/Map/BPFHIR.ttl -n tag:BPfhir123 -e '
       return require("@shexjs/node").load({shexc: ["test/Map/BPunitsDAM.shex"]}, null).
       then(function (loaded) {
       const db = require("@shexjs/extension-map").materializer(loaded.schema).
       materialize(validator.semActHandler.results["http://shex.io/extensions/Map/#"], "tag:b0").
       getQuads(null, null, null);
       const w = require("n3").Writer({ prefixes: { map: "http://shex.io/extensions/Map/#" } });
       w.addTriples(db); w.end(function (error, result) { console.log(result); });
       });'
    */
    return eval("function (validator) {\n" + cmds.exec + "}")(validator);
  } else {
    if (!cmds.quiet)
      if ("errors" in res && Object.keys(validator.semActHandler.results).length) {
        res.semActResults = validator.semActHandler.results;
      }
    return res;
  }

  async function grep (fixedMap) {
    const passes = fixedMap.reduce((acc, row) => {
      if (cmds.verbose)
        process.stdout.write('checking ' + JSON.stringify(row))
      const res = resultMapToShapeExprTest(validator.validateShapeMap([row]));
      if (cmds.verbose)
        process.stdout.write(' -> ' + !('errors' in res) + "\n")
      return "errors" in res
        ? acc
        : acc.concat(cmds.list ? row.node : res);
    }, []);
    return cmds.list
      ? passes
    :passes.length > 1
      ? { type: "SolutionList", solutions: passes }
    : passes.length === 1
      ? passes[0]
      : {};
  }
}

async function loadRDFmanifest (cmds) {

  // from a manifest supplied on the command line
  const mf = "http://www.w3.org/2001/sw/DataAccess/tests/test-manifest#"; // mf: namespace in the manifest file.
  const sht = "http://www.w3.org/ns/shacl/test-suite#";
  try {
    const loaded = await ShExNode.load(
      null, // no schema
      {turtle: cmds["turtle-manifest"] || [], jsonld: cmds["jsonld-manifest"] || []},
      SchemaOptions, undefined
    );
    const testNodes = cmds["test-name"].length ?
        cmds["test-name"].reduce((ret, testName) => {
          const pattern = RegExp(testName);
          loaded.data.getQuads(null, mf+"name", null).filter(function (triple) {
            if (triple.object.value.match(pattern))
              ret.push(triple.subject);
          });
          return ret;
        }, []) :
        loaded.data.getQuads(null, mf+"action", null).map(function (t) {
          return t.subject;
        });
    const tests = testNodes.map(function (subject) {
      const action = loaded.data.getQuads(subject, mf+"action", null)[0].object;
      const validatorOptions = Object.assign({}, ValidatorOptions);
      const schemaOptions = Object.assign({}, SchemaOptions);
      const traits = loaded.data.getQuads(subject, sht+"trait", null);
      traits.forEach(function (t) {
        let tStr = t.object.value.substr(sht.length);
        tStr = tStr.substr(0, 1).toLowerCase() + tStr.substr(1);
        if (tStr in TraitToOption)
          validatorOptions[TraitToOption[tStr]] = tStr;
      });

      return [["schema", "schemaURL", true ],
              ["shape" , "shape"    , false],
              ["data"  , "dataURL"  , true ],
              ["focus" , "node"     , false],
              ["map"   , "mapURL"   , false]].reduce(function (ret, elt) {
                // Command like arguments override *each* manifest entry.
                if (cmds[elt[1]] &&
                    !(Array.isArray(cmds[elt[1]]) && cmds[elt[1]].length === 0)) {
                  ret[elt[1]] = cmds[elt[1]];
                } else {
                  const m = loaded.data.getQuads(action, sht+elt[0], null);
                  if (m.length > 0) {
                    const v = ShExTerm.rdfJsTerm2Ld(m[0].object);
                    ret[elt[1]] = elt[2] ? [v] : v;
                  }
                }
                return ret;
              }, {json: [], jsonld: [],
                  validatorOptions: validatorOptions,
                  schemaOptions: schemaOptions}); // @@ no way to specify jsonld in manifest
    });
    return queueTests(tests, cmds);
  } catch (e) {
    console.error("failed to load manifest file \"" +
                  ((cmds["turtle-manifest"] || []).concat(cmds["jsonld-manifest"] || [])) +
                  "\":", e, e.stack);
    return ExitCode.manifest_not_found;
  }
}

function injectCertainCommandLineArgs (run, cmds) {
  const ret = Object.assign({}, run);
  if ("quiet" in cmds)
    ret.quiet = cmds.quiet;
  return ret;
}

function relUrlOrFile (rel, base) {
  if (base.match(/^[a-z]+:\/\//))
    return new URL(rel, base).href;
  return Path.join(base, base.endsWith('/') ? '.' : '..', rel);
}

function loadJSONmanifest (jsonManifests, parser, cmds) {
  return jsonManifests.map(async function (jm) {
    let [curAct, errorCode] = ["load", ExitCode.manifest_not_found];
    try {
      const p = await ShExNode.GET(jm);
      [curAct, errorCode] = ["process", ExitCode.manifest_error];
      let d = parser(p.text);

        // normalize the input
        if (!Array.isArray(d)) {
          if ("@graph" in d) // Extract from the JSON-LD manifest format.
            d = d["@graph"][0].entries.map(function (t) {
              const options = Object.assign({}, ValidatorOptions);
              (t.trait || []).forEach(function (tStr) {
                tStr = tStr.substr(0, 1).toLowerCase() + tStr.substr(1);
                if (tStr in TraitToOption)
                  options[TraitToOption[tStr]] = tStr;
              });
              return Object.assign(
                { name: t.name,
                  schemaURL: t.action.schema,
                  dataURL: t.action.data,
                  options: options },
                "shape" in t.action ? {shape: t.action.shape} : {},
                "focus" in t.action ? {node: t.action.focus} : {},
                "map" in t.action ? {queryMap: t.action.map} : {}
              );
            });
          else // Hopefully an object like { schemaURL: "t.shex" , shape: "S", dataURL: "t.ttl", "node": "s" }
            d = [d];
        }

        d = d.map(x => injectCertainCommandLineArgs(x, cmds));

        if (cmds["test-name"].length) // Include only tests listed in --test-name.
          d = d.filter(function (elt) {
            return cmds["test-name"].reduce(function (ret, n) {
              const pattern = RegExp(n);
              const name = "name" in elt
                    ? elt.name
                    : "".concat(elt.schemaLabel || '', '/', elt.dataLabel || '');
              return ret || name.match(pattern);
            }, false);
          });

        d.forEach(function (elt) {
          // change .shex as found in test manifest to .schema as found in demo manifests
          if ("shex" in elt) {
            elt["schema"] = elt["shex"]
            delete elt["shex"];
          }
          if ("queryMapURL" in elt) {
            elt["mapURL"] = elt["queryMapURL"]
            delete elt["queryMapURL"];
          }

          // Turn test manifest format into common ShEx manifest format.
          ([{from: "schema", asText: "schemaP", mediaType: "text/shex"  , asUrl: "schemaURL"},
            {from: "json"  , asText: "schemaP", mediaType: "text/json"  , asUrl: "json"},
            {from: "data"  , asText: "dataP"  , mediaType: "text/turtle", asUrl: "dataURL"  },
            {from: "jsonld", asText: "dataP"  , mediaType: "text/jsonld", asUrl: "jsonld"  }])
            .forEach(pair => {
              if (pair.from in elt) { // looks URL-ish
                const values = Array.isArray(elt[pair.from])
                      ? elt[pair.from]
                      : [elt[pair.from]];
                delete elt[pair.from];
                elt[pair.asUrl] = values.map(
                  text =>
                    /[ <>]/.test(text)
                    ? { text, /*mediaType: pair.mediaType,*/ url: p.url }
                  : relUrlOrFile(text, p.url)
                );
              } else if (pair.asUrl in elt) {
                elt[pair.asUrl] = [relUrlOrFile(elt[pair.asUrl], p.url)];
              } else {
                elt[pair.asUrl] = [];
              }
            });

          // Command like arguments override *each* manifest entry.
          ["node", "shape", "queryMap", "mapURL"].forEach(function (attr) {
            if (attr in cmds)
              elt[attr] = cmds[attr];
          });

          // Resolve URL parameters.
          ["mapURL"].forEach(function (attr) {
            if (attr in elt) {
              elt[attr] = relUrlOrFile(elt[attr], p.url)
            }
          });

          elt.schemaOptions = Object.assign({}, SchemaOptions);
          if ("options" in elt) {
            elt.validatorOptions = elt.options;
            delete elt.options;
          } else
            elt.validatorOptions = ValidatorOptions;
          if ("result" in elt && elt.result !== null && typeof elt.result !== "boolean")
            elt.result = relUrlOrFile(elt.result, p.url);
        });
        return await queueTests(d, cmds);
    } catch (e) {
      console.error(`failed to ${curAct} json manifest: ` + (e.stack || e));
      return errorCode;
    }
  });
}

function loadCommandLine (cmds) {

  // Set implicit commands
  if ("result" in cmds) { // "true" and "false" are reserved.
    if (cmds.result === "true") cmds.result = true;
    else if (cmds.result === "false") cmds.result = false;
  }
  if ("slurp-all" in cmds)
    cmds.slurp = "true";

  if (cmds.invocation) {
    console.log(getInvocation(cmds));
  }
  if ("regex-module" in cmds) {
    if (cmds["regex-module"] === "?") {
      // "--regex-module ?" lists the known regular expression modules.
      return new Promise(function (resolve, reject) {
        Fs.readdir(Path.join(__dirname, REGEX_MODULES), (err, fns) => {
          if (err) throw Error(err);
          fns.forEach(fn => {
            if (fn.endsWith(".js")) {
              try {
                const m = require(REGEX_MODULES + fn);
                console.log("  --regex-module " + m.name + " -- " + m.description);
              } catch (e) {  }
            }
          });
          resolve(0);
        });
      });
    } else {
      ValidatorOptions.regexModule = getRegexModule(cmds["regex-module"]);
    }
  }
  const schemaOptions = Object.assign({}, SchemaOptions);
  if (cmds.skipCycleCheck)
    schemaOptions.skipCycleCheck = true;
  return loadSchemaAndData(cmds, ValidatorOptions, schemaOptions, cmds);
}

class FileCache {
  constructor () { this.seen = {}; }

  async read (path) {
    if (!(path in this.seen))
      this.seen[path] = Fs.promises.readFile(Path.resolve(__dirname, path), "utf-8");
    return this.seen[path];
  }
}

function runServer (serverLoaded, serverParms, serverOptions, cmds) {
  const app       = new (require("koa"))();
  const {koaBody} = require("koa-body");
  const log       = serverParms.quiet ? () => undefined : console.log;
  const fileCache = new FileCache();
  let serverUrl;
  try {
    serverUrl = new URL(serverParms.serve);
  } catch (e) {
    throw Error(`Unable to parse requested server URL "${serverParms.serve}"`)
  }
  const requestedPort = serverUrl.port === '' ? 80 : serverUrl.port;

  let stopAfter = serverParms["serve-n"];
  if (stopAfter === undefined || stopAfter === -1)
    stopAfter = Infinity;

  const parsedMethods = ["GET", "POST"];

  const server = app.use(koaBody({
    parsedMethods,
    multipart: true,
    // formLimit: "64 kb",
    formidable: {
      uploadDir: Path.resolve(__dirname, "../rest/uploads")
    }
  })).use(koaHandler).listen(requestedPort);
  const serverAddress = server.address();
  if (!serverAddress) {
    const suggestion = serverUrl.port === ''
          ? ` Try adding a port (> 1024) like http://${serverUrl.hostname}:1234${serverUrl.pathname}`:
          serverUrl.port < 1024 ?
          ' Try a port > 1023'
          : '';
    throw Error(`Unable to bind port ${serverUrl.port || 80}.${suggestion}`);
  }

  const rootUrl = new URL(`http://${serverUrl.hostname}:${serverAddress.port}/`);
  const baseUrl = new URL(serverUrl.pathname, rootUrl)

  if (serverParms.terse) {
    log('host: %s port: %s', serverUrl.hostname, serverAddress.port);
  } else {
      log('Web interface: <%s>', baseUrl.href);
    if (baseUrl.pathname !== '/')
      log('HTML interface: <%s>', rootUrl.href);
    log();
    log('Test with a supplied schema and data:');
    log(`  curl -i %s \\
    -F "schema=@./node_modules/shex-examples/IssueSchema.shex" \\
    -F "shape=#IssueShape" \\
    -F "data=@./node_modules/shex-examples/Issue1.ttl" \\
    -F "node=#Issue1"`, baseUrl.href);
    log('or preload the schema and just supply the data:');
    log(`  %s \\
    -x ./node_modules/shex-examples/IssueSchema.shex \\
    -s \'#IssueShape\' \\
    -S `, Argv1, serverParms.serve);
    log('and pass only the data parameters:');
    log(`  curl -i %s \\
    -F "data=@./node_modules/shex-examples/Issue1.ttl" \\
    -F "node=#Issue1"`, baseUrl.href);
    log('Note that shape and node can be relative or prefixed URLs.');
    log();
    log('Press CTRL+C to stop...');
  }

  async function koaHandler (ctx, next) {
    switch (new URL(ctx.originalUrl, "http://a.example").pathname) {
    case serverUrl.pathname:
      await serveKoaValidationRequest(ctx);
      await next;
      break;
    case "/":
      ctx.body = await fileCache.read("../rest/index.html");
      ctx.type = 'text/html'
      break;
    default:
      ctx.status = 404;
      ctx.body = `failed to ${ctx.method} ${ctx.request.url}\n`
      ctx.type = 'text/plain';
    }
    log(`${ctx.ips.length > 0 ? ctx.ips[ctx.ips.length - 1] : ctx.ip}: ${ctx.method} ${ctx.request.url} ${ctx.status} ${ctx.type} ${ctx.length}`);
    if (!--stopAfter)
      server.close();
  }

  async function serveKoaValidationRequest (ctx) {
      const parms = {
        schema: { type: "Schema" }, shape:undefined, schemaMeta: [],
        data: new N3.Store(), node:undefined, dataMeta: [], nodeType:undefined
      };
      if (parsedMethods.indexOf(ctx.request.method) === -1)
        ctx.throw(500, `only supports ${parsedMethods.join(', ')} now`);

      const unlinkMe = await Promise.all(Object.keys(ctx.request.files || []).reduce((acc, key) => {
        let fz = ctx.request.files[key];
        if (!Array.isArray(fz))
          fz = [fz];
        return acc.concat(fz.map(
          async file => {
            const url = new URL(file.originalFilename, baseUrl);
            const text = await Fs.promises.readFile(file.filepath, "utf8");
            await mergeParm(parms, key, text, url, file.type);
            return {key, text, url, file}; // only really need file.path; rest for debugging
          }
        ))
      }, []))

      try {
        for (let key of ['query', 'body'])
          // e.g. schema, shape, data, node, ...
          for (let param in ctx.request[key])
            await mergeParm(parms, param, ctx.request[key][param], baseUrl, null);

        // Default to serverLoaded (data loaded with server).
        (['schema', 'data']).forEach(
          key => {
            if (parms[key + "Meta"].length === 0) {
              if (serverLoaded[key + "Meta"].length > 0) {
                parms[key] = serverLoaded[key];
                parms[key + "Meta"] = serverLoaded[key + "Meta"];
              } else {
                throw makeError(`No ${key} specified.`, 400);
              }
            }
          });

        if (parms['queryMap']) { // if we loaded a queryMap
          try {
            // try parsing as JSON
            parms.queryMap = ShExUtil.absolutizeShapeMap(JSON.parse(parms['queryMap']),
                                                            baseUrl.href);
          } catch (e) {
            // try parsing as ShapeMap string
            const schemaMeta = parms.schemaMeta.length > 0
                  ? parms.schemaMeta[0]
                  : { base: baseUrl.href, prefixes: {} };
            const dataMeta = parms.dataMeta.length > 0
                  ? parms.dataMeta[0]
                  : { base: baseUrl.href, prefixes: {} };
            parms.queryMap = ShapeMap.Parser.construct(baseUrl.href, schemaMeta, dataMeta)
              .parse(parms['queryMap']);
          }
        } else { // else look for node and shape
          (['node', 'shape']).forEach(
            key => {
              if (!parms[key]) {
                if (key in serverParms)
                  parms[key] = serverParms[key];
                else
                  throw makeError(`No ${key} specified.`, 400);
              }
            }
          )
        }

        let options = serverOptions;
        if ("regex-module" in parms)
          options = extend(options, {
            regexModule: require(REGEX_MODULES + parms["regex-module"])
          });

        // Wrap in RdfJsDb for neighborhood-api.
        if (!("getNeighborhood" in parms.data)) // !! clean up db chaos
          parms.data = RdfJsDb(parms.data);
        let result = await findNodesAndValidate(parms, parms, options, parms.schema.start, cmds);

        if ("results" in result)
          result = result.results; // otherwise just report the invoked parms.

        if (ctx.request.body.output === "html") {
          ctx.body = populateTemplate(
            await fileCache.read("../rest/validate.template"),
            Object.assign({}, parms,
                          {result: JSON.stringify(result, null, 2)}
                         )
          );
          ctx.type = 'text/html'
        } else {
          ctx.body = JSON.stringify(result, null, 2)+"\n";
          ctx.type = 'application/json'
        }

      } catch (e) {
        const stack = typeof e === "object" && "stack" in e ? e.stack : e;
        const msg = typeof e === "object" && "message" in e ? e.message : e;
        console.warn(stack);
        ctx.body = {
          type: "ParsingError",
          errors: [msg]
        };
        ctx.type = 'application/json'
        ctx.status = "status" in e ? e.status : 500;
      }

    unlinkMe.forEach(x => Fs.unlinkSync(x.file.filepath));
  }
}

function populateTemplate (templateStr, vars) {
  return Object.keys(vars).reduce((r, p) => {
    return r.replace("["+p+"]", vars[p]);
  }, templateStr)
}

async function mergeParm (parms, parm, text, url, type) {
  switch (parm) {
  case "schema":
    let part = null;
    const prefixes = {};
    try {
      part = JSON.parse(text);
    } catch (e) {
      const parser = ShExParser.construct(url.href, prefixes);
      part = parser.parse(text/*, base, opts, filename*/);
    }
    const left = { schema: parms.schema, schemaMeta: parms.schemaMeta[0] };
    const right = { schema: part, schemaMeta: {
      url: url.href, importers: [], base: url.href, prefixes
    } };
    new ShExMerger(left, right, true, true).merge();
    parms.schemaMeta.push({prefixes, base: url.href})
    break;
  case "data":
    const tpz = await new Promise((resolve, reject) => {
      const parser = new N3.Parser({ baseIRI: url.href });
      parser.parse(text, function (error, quad, prefixes) {
        if (error) {
          error.message = 'Error parsing data: ' + error.message;
          if (text.indexOf("\n") === -1)
            error.message += "\n  did you send a filename instead of a file?";
          reject(error);
        }
        if (quad)
          parms.data.addQuad(quad);
        else
          resolve(prefixes);
      });
    })
    parms.dataMeta.push({prefixes: tpz, base: url.href})
    break;
  default:
    // These have no merge semantics so just overwrite.
    // node and shape will be evaluated as relative URLs in findNodesAndValidate.
    parms[parm] = text;
  }
}

function objKeyVal (pairs) {
  const ret = {};
  pairs.forEach(pair => ret[pair[0]] = pair[1]);
  return ret;
}

function makeError (msg, status) {
  const ret = Error(msg);
  ret.status = status;
  return ret;
}

function getRegexModule (module) {
  if (module) {
    try {
      return require(module).RegexpModule;
    } catch (e1) {
      try {
        return require(REGEX_MODULES + module).RegexpModule;
      } catch (e2) {
        throw e1;
      }
    }
  }
}

function extend (base) {
  if (!base) base = {};
  for (let i = 1, l = arguments.length, arg; i < l && (arg = arguments[i] || {}); i++)
    for (let name in arg)
      base[name] = arg[name];
  return base;
}

